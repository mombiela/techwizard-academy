Document (globalcampus.site/namespace.stxt): Estado y Ciclo de Vida
	Header: Introducción
	Content:
		El **estado** y el **ciclo de vida** son conceptos fundamentales en React que permiten crear componentes interactivos y dinámicos. El estado representa datos que cambian con el tiempo y afectan la renderización del componente, mientras que el ciclo de vida se refiere a las diferentes etapas por las que pasa un componente desde su montaje hasta su desmontaje.

		En este tema, exploraremos cómo manejar el estado y el ciclo de vida en componentes de clase y funcionales utilizando hooks.

	Subheader: Estado en Componentes de Clase
	Content:
		En los componentes de clase, el estado se define en el constructor y se actualiza utilizando el método `setState()`. El estado es un objeto que almacena información específica del componente y puede cambiar con el tiempo, provocando una re-renderización del componente.

		**Definiendo y usando el estado:**

		Code:
			import React from 'react';

			class Contador extends React.Component {
				constructor(props) {
					super(props);
					this.state = {
						contador: 0
					};
				}

				incrementar = () => {
					this.setState({ contador: this.state.contador + 1 });
				};

				render() {
					return (
						<div>
							<p>Contador: {this.state.contador}</p>
							<button onClick={this.incrementar}>Incrementar</button>
						</div>
					);
				}
			}

		Content:
			En este ejemplo, el componente `Contador` tiene un estado inicial `contador` con valor `0`. Al hacer clic en el botón "Incrementar", el método `incrementar` actualiza el estado usando `setState()`, lo que provoca que el componente se vuelva a renderizar mostrando el nuevo valor.

	Subheader: Ciclo de Vida en Componentes de Clase
	Content:
		Los componentes de clase tienen métodos especiales que se ejecutan en diferentes momentos del ciclo de vida del componente. Estos métodos permiten ejecutar código en momentos específicos, como después de que el componente se monte o antes de que se actualice.

		**Principales métodos del ciclo de vida:**
		
		* **componentDidMount()**: Se ejecuta después de que el componente se ha montado en el DOM. Ideal para realizar peticiones de datos.
		* **componentDidUpdate(prevProps, prevState)**: Se ejecuta después de que el componente se ha actualizado. Útil para reaccionar a cambios en las props o el estado.
		* **componentWillUnmount()**: Se ejecuta justo antes de que el componente se desmonte del DOM. Útil para limpiar recursos como temporizadores o suscripciones.

		**Ejemplo usando métodos del ciclo de vida:**

		Code:
			import React from 'react';

			class Reloj extends React.Component {
				constructor(props) {
					super(props);
					this.state = { hora: new Date() };
				}

				componentDidMount() {
					this.timerID = setInterval(() => this.tick(), 1000);
				}

				componentWillUnmount() {
					clearInterval(this.timerID);
				}

				tick() {
					this.setState({ hora: new Date() });
				}

				render() {
					return (
						<div>
							<h2>Son las {this.state.hora.toLocaleTimeString()}.</h2>
						</div>
					);
				}
			}

		Content:
			En este ejemplo, el componente `Reloj` inicializa el estado con la hora actual. Cuando el componente se monta, `componentDidMount()` configura un temporizador que actualiza la hora cada segundo mediante el método `tick()`. Cuando el componente se desmonta, `componentWillUnmount()` limpia el temporizador para evitar fugas de memoria.

	Subheader: Estado y Ciclo de Vida en Componentes Funcionales con Hooks
	Content:
		Con la introducción de los **hooks** en React, es posible manejar el estado y el ciclo de vida en componentes funcionales de manera sencilla y concisa. Los hooks más utilizados para estos propósitos son `useState` y `useEffect`.

	Subheader: useState Hook
	Content:
		El hook `useState` permite agregar estado a un componente funcional. Retorna un par de valores: el estado actual y una función para actualizarlo.

		**Ejemplo usando useState:**

		Code:
			import React, { useState } from 'react';

			function Contador() {
				const [contador, setContador] = useState(0);

				return (
					<div>
						<p>Contador: {contador}</p>
						<button onClick={() => setContador(contador + 1)}>Incrementar</button>
					</div>
				);
			}

		Content:
			Aquí, el componente `Contador` inicializa el estado `contador` en `0`. Al hacer clic en el botón, se actualiza el estado usando `setContador`, y el componente se re-renderiza mostrando el nuevo valor.

	Subsubheader: useEffect Hook
	Content:
		El hook `useEffect` permite realizar efectos secundarios en componentes funcionales, reemplazando la funcionalidad de los métodos del ciclo de vida como `componentDidMount`, `componentDidUpdate` y `componentWillUnmount`.

		**Ejemplo usando useEffect:**

		Code:
			import React, { useState, useEffect } from 'react';

			function Reloj() {
				const [hora, setHora] = useState(new Date());

				useEffect(() => {
					const timerID = setInterval(() => {
						setHora(new Date());
					}, 1000);

					// Cleanup al desmontar el componente
					return () => clearInterval(timerID);
				}, []);

				return (
					<div>
						<h2>Son las {hora.toLocaleTimeString()}.</h2>
					</div>
				);
			}

		Content:
			En este ejemplo, `useEffect` configura un temporizador cuando el componente se monta y retorna una función de limpieza que se ejecuta cuando el componente se desmonta, similar a `componentDidMount` y `componentWillUnmount` en componentes de clase.

	Subheader: Actualización Condicional con useEffect
	Content:
		`useEffect` puede configurarse para ejecutarse sólo cuando ciertas variables cambian, pasando un arreglo de dependencias como segundo argumento.

		**Ejemplo de actualización condicional:**

		Code:
			import React, { useState, useEffect } from 'react';

			function Usuario({ userID }) {
				const [userData, setUserData] = useState(null);

				useEffect(() => {
					fetch(`https://api.example.com/users/${userID}`)
						.then(response => response.json())
						.then(data => setUserData(data));
				}, [userID]); // Se ejecuta cuando userID cambia

				if (!userData) return <p>Cargando...</p>;

				return (
					<div>
						<h3>{userData.name}</h3>
						<p>{userData.email}</p>
					</div>
				);
			}

		Content:
			Este componente `Usuario` realiza una petición para obtener datos de usuario cada vez que el prop `userID` cambia, gracias al arreglo de dependencias `[userID]` pasado a `useEffect`.

	Subheader: Múltiples useEffect y Organización del Código
	Content:
		Es posible tener múltiples llamadas a `useEffect` en un mismo componente para separar diferentes efectos y mantener el código organizado.

		**Ejemplo con múltiples useEffect:**

		Code:
			import React, { useState, useEffect } from 'react';

			function EjemploMultipleEffects() {
				const [contador, setContador] = useState(0);
				const [titulo, setTitulo] = useState('Título inicial');

				useEffect(() => {
					document.title = `Has hecho clic ${contador} veces`;
				}, [contador]);

				useEffect(() => {
					console.log(`El título ha cambiado a: ${titulo}`);
				}, [titulo]);

				return (
					<div>
						<p>Has hecho clic {contador} veces</p>
						<button onClick={() => setContador(contador + 1)}>Incrementar Contador</button>
						<input value={titulo} onChange={e => setTitulo(e.target.value)} />
					</div>
				);
			}

		Content:
			En este ejemplo, un `useEffect` actualiza el título de la página cuando el contador cambia, y otro registra en la consola cuando el título cambia. Esto permite mantener los efectos separados y el código más legible.

	Subheader: Conclusión
	Content:
		Comprender y manejar el **estado** y el **ciclo de vida** es esencial para construir aplicaciones React interactivas y eficientes. Mientras que los componentes de clase utilizan métodos específicos para estos propósitos, los componentes funcionales con hooks ofrecen una forma más sencilla y flexible de lograr lo mismo. Practicar con `useState` y `useEffect` te permitirá crear componentes reactivos y mantener tu código limpio y organizado.

		En el próximo tema, exploraremos cómo manejar eventos en React para interactuar con los usuarios de manera efectiva.
